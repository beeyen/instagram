{"version":3,"sources":["webpack:///webpack/bootstrap 3f21eb9a7296943e61aa","webpack:///./~/transducers.js/transducers.js","webpack:///./docs/js/main.js"],"names":["consol","log","map","x","foo"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC/DA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS,UAAU,aAAa;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS,UAAU,aAAa;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS,UAAU,aAAa;AACxD;AACA,mCAAmC,cAAc,EAAE;AACnD;;AAEA;AACA,mCAAmC,mBAAmB;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS,UAAU,aAAa;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,UAAU;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,UAAU;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS,UAAU,aAAa;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,SAAS,UAAU,aAAa;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACr8BA;;;;;;AAEAA,OAAOC,GAAP,CAAW,sBAAEC,GAAF,CAAM,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,CAAN,EAAiB;AAAA,SAAKC,IAAE,CAAP;AAAA,CAAjB,CAAX;AACAC,M","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3f21eb9a7296943e61aa","\n// basic protocol helpers\n\nvar symbolExists = typeof Symbol !== 'undefined';\n\nvar protocols = {\n  iterator: symbolExists ? Symbol.iterator : '@@iterator'\n};\n\nfunction throwProtocolError(name, coll) {\n  throw new Error(\"don't know how to \" + name + \" collection: \" +\n                  coll);\n}\n\nfunction fulfillsProtocol(obj, name) {\n  if(name === 'iterator') {\n    // Accept ill-formed iterators that don't conform to the\n    // protocol by accepting just next()\n    return obj[protocols.iterator] || obj.next;\n  }\n\n  return obj[protocols[name]];\n}\n\nfunction getProtocolProperty(obj, name) {\n  return obj[protocols[name]];\n}\n\nfunction iterator(coll) {\n  var iter = getProtocolProperty(coll, 'iterator');\n  if(iter) {\n    return iter.call(coll);\n  }\n  else if(coll.next) {\n    // Basic duck typing to accept an ill-formed iterator that doesn't\n    // conform to the iterator protocol (all iterators should have the\n    // @@iterator method and return themselves, but some engines don't\n    // have that on generators like older v8)\n    return coll;\n  }\n  else if(isArray(coll)) {\n    return new ArrayIterator(coll);\n  }\n  else if(isObject(coll)) {\n    return new ObjectIterator(coll);\n  }\n}\n\nfunction ArrayIterator(arr) {\n  this.arr = arr;\n  this.index = 0;\n}\n\nArrayIterator.prototype.next = function() {\n  if(this.index < this.arr.length) {\n    return {\n      value: this.arr[this.index++],\n      done: false\n    };\n  }\n  return {\n    done: true\n  }\n};\n\nfunction ObjectIterator(obj) {\n  this.obj = obj;\n  this.keys = Object.keys(obj);\n  this.index = 0;\n}\n\nObjectIterator.prototype.next = function() {\n  if(this.index < this.keys.length) {\n    var k = this.keys[this.index++];\n    return {\n      value: [k, this.obj[k]],\n      done: false\n    };\n  }\n  return {\n    done: true\n  }\n};\n\n// helpers\n\nvar toString = Object.prototype.toString;\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nfunction isObject(x) {\n  return x instanceof Object &&\n    Object.getPrototypeOf(x) === Object.getPrototypeOf({});\n}\n\nfunction isNumber(x) {\n  return typeof x === 'number';\n}\n\nfunction Reduced(value) {\n  this['@@transducer/reduced'] = true;\n  this['@@transducer/value'] = value;\n}\n\nfunction isReduced(x) {\n  return (x instanceof Reduced) || (x && x['@@transducer/reduced']);\n}\n\nfunction deref(x) {\n  return x['@@transducer/value'];\n}\n\n/**\n * This is for transforms that may call their nested transforms before\n * Reduced-wrapping the result (e.g. \"take\"), to avoid nested Reduced.\n */\nfunction ensureReduced(val) {\n  if(isReduced(val)) {\n    return val;\n  } else {\n    return new Reduced(val);\n  }\n}\n\n/**\n * This is for tranforms that call their nested transforms when\n * performing completion (like \"partition\"), to avoid signaling\n * termination after already completing.\n */\nfunction ensureUnreduced(v) {\n  if(isReduced(v)) {\n    return deref(v);\n  } else {\n    return v;\n  }\n}\n\nfunction reduce(coll, xform, init) {\n  if(isArray(coll)) {\n    var result = init;\n    var index = -1;\n    var len = coll.length;\n    while(++index < len) {\n      result = xform['@@transducer/step'](result, coll[index]);\n      if(isReduced(result)) {\n        result = deref(result);\n        break;\n      }\n    }\n    return xform['@@transducer/result'](result);\n  }\n  else if(isObject(coll) || fulfillsProtocol(coll, 'iterator')) {\n    var result = init;\n    var iter = iterator(coll);\n    var val = iter.next();\n    while(!val.done) {\n      result = xform['@@transducer/step'](result, val.value);\n      if(isReduced(result)) {\n        result = deref(result);\n        break;\n      }\n      val = iter.next();\n    }\n    return xform['@@transducer/result'](result);\n  }\n  throwProtocolError('iterate', coll);\n}\n\nfunction transduce(coll, xform, reducer, init) {\n  xform = xform(reducer);\n  if(init === undefined) {\n    init = xform['@@transducer/init']();\n  }\n  return reduce(coll, xform, init);\n}\n\nfunction compose() {\n  var funcs = Array.prototype.slice.call(arguments);\n  return function(r) {\n    var value = r;\n    for(var i=funcs.length-1; i>=0; i--) {\n      value = funcs[i](value);\n    }\n    return value;\n  }\n}\n\n// transformations\n\nfunction transformer(f) {\n  var t = {};\n  t['@@transducer/init'] = function() {\n    throw new Error('init value unavailable');\n  };\n  t['@@transducer/result'] = function(v) {\n    return v;\n  };\n  t['@@transducer/step'] = f;\n  return t;\n}\n\nfunction bound(f, ctx, count) {\n  count = count != null ? count : 1;\n\n  if(!ctx) {\n    return f;\n  }\n  else {\n    switch(count) {\n    case 1:\n      return function(x) {\n        return f.call(ctx, x);\n      }\n    case 2:\n      return function(x, y) {\n        return f.call(ctx, x, y);\n      }\n    default:\n      return f.bind(ctx);\n    }\n  }\n}\n\nfunction arrayMap(arr, f, ctx) {\n  var index = -1;\n  var length = arr.length;\n  var result = Array(length);\n  f = bound(f, ctx, 2);\n\n  while (++index < length) {\n    result[index] = f(arr[index], index);\n  }\n  return result;\n}\n\nfunction arrayFilter(arr, f, ctx) {\n  var len = arr.length;\n  var result = [];\n  f = bound(f, ctx, 2);\n\n  for(var i=0; i<len; i++) {\n    if(f(arr[i], i)) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\n\nfunction Map(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nMap.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nMap.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nMap.prototype['@@transducer/step'] = function(res, input) {\n  return this.xform['@@transducer/step'](res, this.f(input));\n};\n\nfunction map(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    if(isArray(coll)) {\n      return arrayMap(coll, f, ctx);\n    }\n    return seq(coll, map(f));\n  }\n\n  return function(xform) {\n    return new Map(f, xform);\n  }\n}\n\nfunction Filter(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nFilter.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nFilter.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nFilter.prototype['@@transducer/step'] = function(res, input) {\n  if(this.f(input)) {\n    return this.xform['@@transducer/step'](res, input);\n  }\n  return res;\n};\n\nfunction filter(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    if(isArray(coll)) {\n      return arrayFilter(coll, f, ctx);\n    }\n    return seq(coll, filter(f));\n  }\n\n  return function(xform) {\n    return new Filter(f, xform);\n  };\n}\n\nfunction remove(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n  return filter(coll, function(x) { return !f(x); });\n}\n\nfunction keep(coll) {\n  return filter(coll, function(x) { return x != null });\n}\n\nfunction Dedupe(xform) {\n  this.xform = xform;\n  this.last = undefined;\n}\n\nDedupe.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nDedupe.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nDedupe.prototype['@@transducer/step'] = function(result, input) {\n  if(input !== this.last) {\n    this.last = input;\n    return this.xform['@@transducer/step'](result, input);\n  }\n  return result;\n};\n\nfunction dedupe(coll) {\n  if(coll) {\n    return seq(coll, dedupe());\n  }\n\n  return function(xform) {\n    return new Dedupe(xform);\n  }\n}\n\nfunction TakeWhile(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nTakeWhile.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nTakeWhile.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nTakeWhile.prototype['@@transducer/step'] = function(result, input) {\n  if(this.f(input)) {\n    return this.xform['@@transducer/step'](result, input);\n  }\n  return new Reduced(result);\n};\n\nfunction takeWhile(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    return seq(coll, takeWhile(f));\n  }\n\n  return function(xform) {\n    return new TakeWhile(f, xform);\n  }\n}\n\nfunction Take(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n}\n\nTake.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nTake.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nTake.prototype['@@transducer/step'] = function(result, input) {\n  if (this.i < this.n) {\n    result = this.xform['@@transducer/step'](result, input);\n    if(this.i + 1 >= this.n) {\n      // Finish reducing on the same step as the final value. TODO:\n      // double-check that this doesn't break any semantics\n      result = ensureReduced(result);\n    }\n  }\n  this.i++;\n  return result;\n};\n\nfunction take(coll, n) {\n  if(isNumber(coll)) { n = coll; coll = null }\n\n  if(coll) {\n    return seq(coll, take(n));\n  }\n\n  return function(xform) {\n    return new Take(n, xform);\n  }\n}\n\nfunction Drop(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n}\n\nDrop.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nDrop.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nDrop.prototype['@@transducer/step'] = function(result, input) {\n  if(this.i++ < this.n) {\n    return result;\n  }\n  return this.xform['@@transducer/step'](result, input);\n};\n\nfunction drop(coll, n) {\n  if(isNumber(coll)) { n = coll; coll = null }\n\n  if(coll) {\n    return seq(coll, drop(n));\n  }\n\n  return function(xform) {\n    return new Drop(n, xform);\n  }\n}\n\nfunction DropWhile(f, xform) {\n  this.xform = xform;\n  this.f = f;\n  this.dropping = true;\n}\n\nDropWhile.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nDropWhile.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nDropWhile.prototype['@@transducer/step'] = function(result, input) {\n  if(this.dropping) {\n    if(this.f(input)) {\n      return result;\n    }\n    else {\n      this.dropping = false;\n    }\n  }\n  return this.xform['@@transducer/step'](result, input);\n};\n\nfunction dropWhile(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    return seq(coll, dropWhile(f));\n  }\n\n  return function(xform) {\n    return new DropWhile(f, xform);\n  }\n}\n\nfunction Partition(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n  this.part = new Array(n);\n}\n\nPartition.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nPartition.prototype['@@transducer/result'] = function(v) {\n  if (this.i > 0) {\n    return ensureUnreduced(this.xform['@@transducer/step'](v, this.part.slice(0, this.i)));\n  }\n  return this.xform['@@transducer/result'](v);\n};\n\nPartition.prototype['@@transducer/step'] = function(result, input) {\n  this.part[this.i] = input;\n  this.i += 1;\n  if (this.i === this.n) {\n    var out = this.part.slice(0, this.n);\n    this.part = new Array(this.n);\n    this.i = 0;\n    return this.xform['@@transducer/step'](result, out);\n  }\n  return result;\n};\n\nfunction partition(coll, n) {\n  if (isNumber(coll)) {\n    n = coll; coll = null;\n  }\n\n  if (coll) {\n    return seq(coll, partition(n));\n  }\n\n  return function(xform) {\n    return new Partition(n, xform);\n  };\n}\n\nvar NOTHING = {};\n\nfunction PartitionBy(f, xform) {\n  // TODO: take an \"opts\" object that allows the user to specify\n  // equality\n  this.f = f;\n  this.xform = xform;\n  this.part = [];\n  this.last = NOTHING;\n}\n\nPartitionBy.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nPartitionBy.prototype['@@transducer/result'] = function(v) {\n  var l = this.part.length;\n  if (l > 0) {\n    return ensureUnreduced(this.xform['@@transducer/step'](v, this.part.slice(0, l)));\n  }\n  return this.xform['@@transducer/result'](v);\n};\n\nPartitionBy.prototype['@@transducer/step'] = function(result, input) {\n  var current = this.f(input);\n  if (current === this.last || this.last === NOTHING) {\n    this.part.push(input);\n  } else {\n    result = this.xform['@@transducer/step'](result, this.part);\n    this.part = [input];\n  }\n  this.last = current;\n  return result;\n};\n\nfunction partitionBy(coll, f, ctx) {\n  if (isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if (coll) {\n    return seq(coll, partitionBy(f));\n  }\n\n  return function(xform) {\n    return new PartitionBy(f, xform);\n  };\n}\n\nfunction Interpose(sep, xform) {\n  this.sep = sep;\n  this.xform = xform;\n  this.started = false;\n}\n\nInterpose.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nInterpose.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nInterpose.prototype['@@transducer/step'] = function(result, input) {\n  if (this.started) {\n    var withSep = this.xform['@@transducer/step'](result, this.sep);\n    if (isReduced(withSep)) {\n      return withSep;\n    } else {\n      return this.xform['@@transducer/step'](withSep, input);\n    }\n  } else {\n    this.started = true;\n    return this.xform['@@transducer/step'](result, input);\n  }\n};\n\n/**\n * Returns a new collection containing elements of the given\n * collection, separated by the specified separator. Returns a\n * transducer if a collection is not provided.\n */\nfunction interpose(coll, separator) {\n  if (arguments.length === 1) {\n    separator = coll;\n    return function(xform) {\n      return new Interpose(separator, xform);\n    };\n  }\n  return seq(coll, interpose(separator));\n}\n\nfunction Repeat(n, xform) {\n  this.xform = xform;\n  this.n = n;\n}\n\nRepeat.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nRepeat.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nRepeat.prototype['@@transducer/step'] = function(result, input) {\n  var n = this.n;\n  var r = result;\n  for (var i = 0; i < n; i++) {\n    r = this.xform['@@transducer/step'](r, input);\n    if (isReduced(r)) {\n      break;\n    }\n  }\n  return r;\n};\n\n/**\n * Returns a new collection containing elements of the given\n * collection, each repeated n times. Returns a transducer if a\n * collection is not provided.\n */\nfunction repeat(coll, n) {\n  if (arguments.length === 1) {\n    n = coll;\n    return function(xform) {\n      return new Repeat(n, xform);\n    };\n  }\n  return seq(coll, repeat(n));\n}\n\nfunction TakeNth(n, xform) {\n  this.xform = xform;\n  this.n = n;\n  this.i = -1;\n}\n\nTakeNth.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nTakeNth.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nTakeNth.prototype['@@transducer/step'] = function(result, input) {\n  this.i += 1;\n  if (this.i % this.n === 0) {\n    return this.xform['@@transducer/step'](result, input);\n  }\n  return result;\n};\n\n/**\n * Returns a new collection of every nth element of the given\n * collection. Returns a transducer if a collection is not provided.\n */\nfunction takeNth(coll, nth) {\n  if (arguments.length === 1) {\n    nth = coll;\n    return function(xform) {\n      return new TakeNth(nth, xform);\n    };\n  }\n  return seq(coll, takeNth(nth));\n}\n\n// pure transducers (cannot take collections)\n\nfunction Cat(xform) {\n  this.xform = xform;\n}\n\nCat.prototype['@@transducer/init'] = function() {\n  return this.xform['@@transducer/init']();\n};\n\nCat.prototype['@@transducer/result'] = function(v) {\n  return this.xform['@@transducer/result'](v);\n};\n\nCat.prototype['@@transducer/step'] = function(result, input) {\n  var xform = this.xform;\n  var newxform = {};\n  newxform['@@transducer/init'] = function() {\n    return xform['@@transducer/init']();\n  };\n  newxform['@@transducer/result'] = function(v) {\n    return v;\n  };\n  newxform['@@transducer/step'] = function(result, input) {\n    var val = xform['@@transducer/step'](result, input);\n    return isReduced(val) ? deref(val) : val;\n  };\n\n  return reduce(input, newxform, result);\n};\n\nfunction cat(xform) {\n  return new Cat(xform);\n}\n\nfunction mapcat(f, ctx) {\n  f = bound(f, ctx);\n  return compose(map(f), cat);\n}\n\n// collection helpers\n\nfunction push(arr, x) {\n  arr.push(x);\n  return arr;\n}\n\nfunction merge(obj, x) {\n  if(isArray(x) && x.length === 2) {\n    obj[x[0]] = x[1];\n  }\n  else {\n    var keys = Object.keys(x);\n    var len = keys.length;\n    for(var i=0; i<len; i++) {\n      obj[keys[i]] = x[keys[i]];\n    }\n  }\n  return obj;\n}\n\nvar arrayReducer = {};\narrayReducer['@@transducer/init'] = function() {\n  return [];\n};\narrayReducer['@@transducer/result'] = function(v) {\n  return v;\n};\narrayReducer['@@transducer/step'] = push;\n\nvar objReducer = {};\nobjReducer['@@transducer/init'] = function() {\n  return {};\n};\nobjReducer['@@transducer/result'] = function(v) {\n  return v;\n};\nobjReducer['@@transducer/step'] = merge;\n\n// building new collections\n\nfunction toArray(coll, xform) {\n  if(!xform) {\n    return reduce(coll, arrayReducer, []);\n  }\n  return transduce(coll, xform, arrayReducer, []);\n}\n\nfunction toObj(coll, xform) {\n  if(!xform) {\n    return reduce(coll, objReducer, {});\n  }\n  return transduce(coll, xform, objReducer, {});\n}\n\nfunction toIter(coll, xform) {\n  if(!xform) {\n    return iterator(coll);\n  }\n  return new LazyTransformer(xform, coll);\n}\n\nfunction seq(coll, xform) {\n  if(isArray(coll)) {\n    return transduce(coll, xform, arrayReducer, []);\n  }\n  else if(isObject(coll)) {\n    return transduce(coll, xform, objReducer, {});\n  }\n  else if(coll['@@transducer/step']) {\n    var init;\n    if(coll['@@transducer/init']) {\n      init = coll['@@transducer/init']();\n    }\n    else {\n      init = new coll.constructor();\n    }\n\n    return transduce(coll, xform, coll, init);\n  }\n  else if(fulfillsProtocol(coll, 'iterator')) {\n    return new LazyTransformer(xform, coll);\n  }\n  throwProtocolError('sequence', coll);\n}\n\nfunction into(to, xform, from) {\n  if(isArray(to)) {\n    return transduce(from, xform, arrayReducer, to);\n  }\n  else if(isObject(to)) {\n    return transduce(from, xform, objReducer, to);\n  }\n  else if(to['@@transducer/step']) {\n    return transduce(from,\n                     xform,\n                     to,\n                     to);\n  }\n  throwProtocolError('into', to);\n}\n\n// laziness\n\nvar stepper = {};\nstepper['@@transducer/result'] = function(v) {\n  return isReduced(v) ? deref(v) : v;\n};\nstepper['@@transducer/step'] = function(lt, x) {\n  lt.items.push(x);\n  return lt.rest;\n};\n\nfunction Stepper(xform, iter) {\n  this.xform = xform(stepper);\n  this.iter = iter;\n}\n\nStepper.prototype['@@transducer/step'] = function(lt) {\n  var len = lt.items.length;\n  while(lt.items.length === len) {\n    var n = this.iter.next();\n    if(n.done || isReduced(n.value)) {\n      // finalize\n      this.xform['@@transducer/result'](this);\n      break;\n    }\n\n    // step\n    this.xform['@@transducer/step'](lt, n.value);\n  }\n}\n\nfunction LazyTransformer(xform, coll) {\n  this.iter = iterator(coll);\n  this.items = [];\n  this.stepper = new Stepper(xform, iterator(coll));\n}\n\nLazyTransformer.prototype[protocols.iterator] = function() {\n  return this;\n}\n\nLazyTransformer.prototype.next = function() {\n  this['@@transducer/step']();\n\n  if(this.items.length) {\n    return {\n      value: this.items.pop(),\n      done: false\n    }\n  }\n  else {\n    return { done: true };\n  }\n};\n\nLazyTransformer.prototype['@@transducer/step'] = function() {\n  if(!this.items.length) {\n    this.stepper['@@transducer/step'](this);\n  }\n}\n\n// util\n\nfunction range(n) {\n  var arr = new Array(n);\n  for(var i=0; i<arr.length; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\nmodule.exports = {\n  reduce: reduce,\n  transformer: transformer,\n  Reduced: Reduced,\n  isReduced: isReduced,\n  iterator: iterator,\n  push: push,\n  merge: merge,\n  transduce: transduce,\n  seq: seq,\n  toArray: toArray,\n  toObj: toObj,\n  toIter: toIter,\n  into: into,\n  compose: compose,\n  map: map,\n  filter: filter,\n  remove: remove,\n  cat: cat,\n  mapcat: mapcat,\n  keep: keep,\n  dedupe: dedupe,\n  take: take,\n  takeWhile: takeWhile,\n  takeNth: takeNth,\n  drop: drop,\n  dropWhile: dropWhile,\n  partition: partition,\n  partitionBy: partitionBy,\n  interpose: interpose,\n  repeat: repeat,\n  range: range,\n\n  LazyTransformer: LazyTransformer\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/transducers.js/transducers.js\n// module id = 0\n// module chunks = 0","import t from 'transducers.js';\n\nconsol.log(t.map([1,2,4,5], x => x+1));\nfoo();\n\n\n\n// WEBPACK FOOTER //\n// ./docs/js/main.js"],"sourceRoot":""}